import type { CLIArguments } from "../../cli-utils";
import { existsSync } from "node:fs";
import { mkdir, readdir, readFile, stat, writeFile } from "node:fs/promises";
import path from "node:path";
import { RawDataFile } from "@luxass/unicode-utils/data-files";
import { toKebabCase } from "@luxass/utils";
import { generateFields } from "@ucdjs/schema-gen";
import { printHelp } from "../../cli-utils";

export interface CLICodegenFieldsCmdOptions {
  flags: CLIArguments<{
    openaiKey?: string;
    outputDir?: string;
    bundle?: boolean | string;
  }>;
  inputPath: string;
}

export async function runFieldCodegen({ inputPath, flags }: CLICodegenFieldsCmdOptions) {
  if (flags?.help || flags?.h) {
    printHelp({
      headline: "Generate Unicode Data Files",
      commandName: "ucd codegen fields",
      usage: "<input> [...flags]",
      tables: {
        Flags: [
          ["--openai-key (-k)", "The OpenAI API key to use. (can also be set using OPENAI_API_KEY env var)"],
          ["--output-dir", "Specify the output directory for generated files (defaults to .codegen)"],
          ["--bundle <filename>", "Combine all generated files into a single file, if no filename is provided, the default is index.ts"],
          ["--help (-h)", "See all available flags."],
        ],
      },
    });
    return;
  }

  // eslint-disable-next-line node/prefer-global/process
  const openaiKey = flags.openaiKey || process.env.OPENAI_API_KEY;
  if (!openaiKey) {
    console.error("No OpenAI API key provided. Please provide an OpenAI API key.");
    return;
  }

  if (inputPath == null) {
    console.error("No input path provided. Please provide an input path.");
    return;
  }

  const resolvedInputPath = path.resolve(inputPath);

  if (!existsSync(resolvedInputPath)) {
    console.error(`invalid input path: ${inputPath}. Please provide a valid input path.`);
    return;
  }

  // eslint-disable-next-line node/prefer-global/process
  const outputDir = flags.outputDir || process.cwd();
  await mkdir(outputDir, { recursive: true });

  const shouldBundle = typeof flags.bundle === "string" || flags.bundle === true;
  const bundleFileName = typeof flags.bundle === "string" ? flags.bundle : "index.ts";

  // check whether or not the input path is a directory or a file
  const isDirectory = (await stat(resolvedInputPath)).isDirectory();

  const files = [];

  if (isDirectory) {
    const dir = await readdir(resolvedInputPath, {
      withFileTypes: true,
      recursive: true,
    });

    for (const file of dir) {
      if (file.isFile()) {
        if (!file.name.endsWith(".txt")) {
          continue;
        }

        files.push(path.join(file.parentPath, file.name));
      }
    }
  } else {
    files.push(resolvedInputPath);
  }

  const promises = files.map(async (filePath) => {
    const content = await readFile(filePath, "utf-8");
    const datafile = new RawDataFile(content);

    if (datafile.heading == null) {
      console.error(`heading for file ${filePath} is null. Skipping file.`);
      return null;
    }

    const code = await generateFields({
      datafile,
      apiKey: openaiKey,
    });

    if (code == null) {
      console.error(`Error generating fields for file: ${filePath}`);
      return null;
    }

    if (!shouldBundle) {
      const fileName = toKebabCase(path.basename(filePath).replace(/\.txt$/, "")).toLowerCase();
      await writeFile(
        path.join(outputDir, `${fileName}.ts`),
        code,
        "utf-8",
      );
    }

    return {
      code,
      // eslint-disable-next-line node/prefer-global/process
      fileName: filePath.replace(`${process.cwd()}/`, ""),
    };
  });

  const generatedCode = await Promise.all(promises);

  if (!shouldBundle) {
    // eslint-disable-next-line no-console
    console.log(`Generated fields for ${files.length} files in ${outputDir}`);
    return;
  }

  let bundledCode = `// This file is generated by ucd codegen. Do not edit this file directly.\n\n`;
  for (const { fileName, code } of generatedCode.filter((obj) => obj != null)) {
    bundledCode += `//#region ${fileName}\n`;
    bundledCode += code;
    bundledCode += `\n//#endregion\n`;
    bundledCode += "\n\n";
  }

  let bundlePath = path.resolve(path.join(outputDir, bundleFileName));
  if (path.extname(bundleFileName) === "") {
    bundlePath = path.join(outputDir, `${bundleFileName}.ts`);
  }

  await writeFile(
    bundlePath,
    bundledCode,
    "utf-8",
  );
  // eslint-disable-next-line no-console
  console.log(`Generated bundled fields in ${bundlePath}`);
}
