import type { ProcessedFile } from "@ucdjs/schema-gen";
import type { CLIArguments } from "../../cli-utils";
import { existsSync } from "node:fs";
import { mkdir, readdir, stat, writeFile } from "node:fs/promises";
import path from "node:path";
import process from "node:process";
import { runSchemagen } from "@ucdjs/schema-gen";
import { printHelp } from "../../cli-utils";
import { CLIError } from "../../errors";
import { output } from "../../output";

export interface CLICodegenFieldsCmdOptions {
  flags: CLIArguments<{
    openaiKey?: string;
    outputDir?: string;
    bundle?: boolean | string;
  }>;
  inputPath: string;
}

function flattenVersion(version: string): string {
  // split version into parts
  const parts = version.split(".");
  // remove trailing zeros
  while (parts.length > 1 && parts[parts.length - 1] === "0") {
    parts.pop();
  }
  return parts.join(".");
}

interface FileWithVersion {
  filePath: string;
  version: string;
}

async function scanFiles(inputPath: string): Promise<FileWithVersion[]> {
  const resolvedInputPath = path.resolve(inputPath);
  const isDirectory = (await stat(resolvedInputPath)).isDirectory();
  const filesWithVersion: FileWithVersion[] = [];

  if (!isDirectory) {
    // single file case - look for version in parent directory name
    const parentDir = path.dirname(resolvedInputPath);
    const versionMatch = parentDir.match(/v(\d+\.\d+\.\d+)/);
    const version = versionMatch ? flattenVersion(versionMatch[1]!) : "unknown";
    filesWithVersion.push({ filePath: resolvedInputPath, version });
  } else {
    const dir = await readdir(resolvedInputPath, {
      withFileTypes: true,
      recursive: true,
    });

    for (const file of dir) {
      if (!file.isFile() || !file.name.endsWith(".txt") || file.name.endsWith("Test.txt")) {
        continue;
      }

      const filePath = path.join(file.parentPath, file.name);
      // extract version from path (e.g., v16.0.0)
      const versionMatch = filePath.match(/v(\d+\.\d+\.\d+)/);
      const version = versionMatch ? flattenVersion(versionMatch[1]!) : "unknown";
      filesWithVersion.push({ filePath, version });
    }
  }

  return filesWithVersion;
}

// write bundled files concurrently
async function writeBundledFile(
  version: string,
  results: ProcessedFile[],
  bundleTemplate: string,
  outputDir: string | undefined,
): Promise<void> {
  let bundledCode = `// This file is generated by ucd codegen. Do not edit this file directly.\n`;
  bundledCode += `// Unicode Version: ${version}\n\n`;

  for (const result of results) {
    const relativePath = path.relative(process.cwd(), result.fileName);
    bundledCode += `\n// #region ${relativePath}\n`;
    bundledCode += result.code;
    bundledCode += `\n// #endregion\n`;
  }

  const bundleFileName = bundleTemplate.replace("{version}", version);
  // handle absolute and relative paths differently than bare filenames
  let bundlePath;
  if (path.isAbsolute(bundleFileName) || bundleFileName.startsWith("./") || bundleFileName.startsWith("../")) {
    bundlePath = path.resolve(bundleFileName);
  } else if (outputDir) {
    bundlePath = path.resolve(path.join(outputDir, bundleFileName));
  } else {
    bundlePath = path.resolve(bundleFileName);
  }

  // ensure .ts extension
  if (!bundlePath.endsWith(".ts")) {
    bundlePath += ".ts";
  }

  // ensure directory exists
  await mkdir(path.dirname(bundlePath), { recursive: true });

  await writeFile(
    bundlePath,
    bundledCode,
    "utf-8",
  );
  output.success(`Generated bundled fields for Unicode ${version} in ${bundlePath}`);
}

export async function runFieldCodegen({ inputPath, flags }: CLICodegenFieldsCmdOptions) {
  if (flags?.help || flags?.h) {
    printHelp({
      headline: "Generate Unicode Data Files",
      commandName: "ucd codegen fields",
      usage: "<input> [...flags]",
      tables: {
        Flags: [
          ["--openai-key (-k)", "The OpenAI API key to use. (can also be set using OPENAI_API_KEY env var)"],
          ["--output-dir", "Specify the output directory for generated files (defaults to .codegen)"],
          ["--bundle <filename>", "Combine generated files into a single file per version. Use {version} placeholder for version-specific naming"],
          ["--help (-h)", "See all available flags."],
        ],
      },
    });
    return;
  }

  const openaiKey = flags.openaiKey || process.env.OPENAI_API_KEY;
  if (!openaiKey) {
    throw new CLIError("No OpenAI API key provided.", {
      details: ["Please provide an OpenAI API key via --openai-key flag or OPENAI_API_KEY environment variable."],
    });
  }

  if (inputPath == null) {
    throw new CLIError("No input path provided.", {
      details: ["Please provide an input path as the first argument."],
    });
  }

  const resolvedInputPath = path.resolve(inputPath);

  if (!existsSync(resolvedInputPath)) {
    throw new CLIError(`Invalid input path: ${inputPath}`, {
      details: ["The specified input path does not exist. Please provide a valid input path."],
    });
  }

  const shouldBundle = typeof flags.bundle === "string" || flags.bundle === true;
  const bundleTemplate = typeof flags.bundle === "string" ? flags.bundle : "index.ts";

  // extract output directory from bundle path if it's relative/absolute
  let outputDir = flags.outputDir;
  if (!outputDir) {
    if (shouldBundle && (path.isAbsolute(bundleTemplate) || bundleTemplate.startsWith("./") || bundleTemplate.startsWith("../"))) {
      outputDir = path.dirname(bundleTemplate);
    } else {
      outputDir = path.join(path.dirname(resolvedInputPath), ".codegen");
    }
  }

  if (outputDir) {
    await mkdir(outputDir, { recursive: true });
  }

  // STEP 1: Scan files without concurrency limits
  const filesWithVersion = await scanFiles(inputPath);

  output.info(`Found ${filesWithVersion.length} files to process.`);

  const results = await runSchemagen({
    files: filesWithVersion,
    openaiKey,
  });

  const writePromises = [];

  if (!shouldBundle) {
    // write individual files with concurrency limit
    writePromises.push(...results.map((result: ProcessedFile) => writeFile(
      path.join(outputDir, `${result.fileName}.ts`),
      result.code,
      "utf-8",
    )));

    await Promise.all(writePromises);
    output.success(`Generated fields for ${results.length} files in ${outputDir}`);
    return;
  }

  // group results by version
  const resultsByVersion = new Map<string, ProcessedFile[]>();
  for (const result of results) {
    const versionResults = resultsByVersion.get(result.version) ?? [];
    versionResults.push(result);
    resultsByVersion.set(result.version, versionResults);
  }

  // write bundled files with concurrency limit
  const bundlePromises = Array.from(resultsByVersion.entries()).map(([version, versionResults]) => writeBundledFile(version, versionResults, bundleTemplate, outputDir));

  await Promise.all(bundlePromises);
}
