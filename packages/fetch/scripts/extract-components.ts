import { existsSync } from "node:fs";
import { readFile, writeFile } from "node:fs/promises";
import path from "node:path";
import process from "node:process";
import { dedent } from "@luxass/utils";
import * as ts from "typescript";

const root = path.resolve(import.meta.dirname, "../");

// List of schemas that exist in @ucdjs/schemas and should NOT be generated
// These are re-exported from @ucdjs/schemas via the main index.ts
const SKIP_SCHEMAS = new Set(["UCDStoreManifest", "FileEntryList"]);

async function run() {
  console.log("extracting components from api.d.ts...");

  const apiDefinitionPath = path.join(root, "src", ".generated", "api.d.ts");
  if (!existsSync(apiDefinitionPath)) {
    throw new Error(`API definition file not found: ${apiDefinitionPath}`);
  }

  const apiDefinition = await readFile(apiDefinitionPath, "utf-8");

  const sourceFile = ts.createSourceFile(
    apiDefinitionPath,
    apiDefinition,
    ts.ScriptTarget.Latest,
    true,
  );

  let content = dedent`
          /**
           * This file is auto-generated by the \`generate:components\` script.
           * Do not edit this file directly.
           * Run \`pnpm generate:components\` to regenerate it.
           */

          import type { components } from "./.generated/api";

  `;

  const generatedSchemas: string[] = [];
  const skippedSchemas: string[] = [];

  function visit(node: ts.Node) {
    if (ts.isInterfaceDeclaration(node) && node.name.text === "components") {
      node.members.forEach((member) => {
        if (ts.isPropertySignature(member)
          && member.name
          && ts.isIdentifier(member.name)
          && member.name.text === "schemas") {
          if (member.type && ts.isTypeLiteralNode(member.type)) {
            member.type.members.forEach((schemaMember) => {
              if (!ts.isPropertySignature(schemaMember) || !ts.isIdentifier(schemaMember.name)) {
                return;
              }

              const schemaName = schemaMember.name.text;
              
              // Skip schemas that should be imported from @ucdjs/schemas
              if (SKIP_SCHEMAS.has(schemaName)) {
                skippedSchemas.push(schemaName);
                return;
              }

              // Generate normal type from OpenAPI
              content += `export type ${schemaName} = components["schemas"]["${schemaName}"];\n`;
              generatedSchemas.push(schemaName);
            });
          }
        }
      });
    }

    ts.forEachChild(node, visit);
  }

  visit(sourceFile);

  // Add comment about skipped schemas
  if (skippedSchemas.length > 0) {
    content += `\n// ${skippedSchemas.join(", ")} are now re-exported from @ucdjs/schemas via the main index.ts`;
  }

  await writeFile(path.join(root, "src", "components.ts"), content);
  
  console.log(`Generated ${generatedSchemas.length} schema types: ${generatedSchemas.join(", ")}`);
  console.log(`Skipped ${skippedSchemas.length} schema types (available from @ucdjs/schemas): ${skippedSchemas.join(", ")}`);
}

run().catch((err) => {
  console.error(err);
  process.exit(1);
});
