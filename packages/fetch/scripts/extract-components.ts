import { existsSync } from "node:fs";
import { readFile, writeFile } from "node:fs/promises";
import path from "node:path";
import process from "node:process";
import { dedent } from "@luxass/utils";
import ts from "typescript";

const root = path.resolve(import.meta.dirname, "../");

async function getSchemasPackageTypes(): Promise<Set<string>> {
  const schemasPackagePath = path.resolve(root, "../schemas/src/index.ts");

  if (!existsSync(schemasPackagePath)) {
    console.warn("@ucdjs/schemas index file not found, no types will be excluded");
    return new Set();
  }

  const schemasContent = await readFile(schemasPackagePath, "utf-8");
  const sourceFile = ts.createSourceFile(
    schemasPackagePath,
    schemasContent,
    ts.ScriptTarget.Latest,
    true,
  );

  const exportedTypes = new Set<string>();

  function visit(node: ts.Node) {
    // Handle: export type { TypeName } from "./module" (only type exports)
    if (ts.isExportDeclaration(node) && node.exportClause && ts.isNamedExports(node.exportClause) && node.isTypeOnly) {
      node.exportClause.elements.forEach((element) => {
        if (ts.isExportSpecifier(element) && element.name) {
          exportedTypes.add(element.name.text);
        }
      });
    }

    // Handle: export type TypeName = ... (type alias declarations)
    if (ts.isTypeAliasDeclaration(node) && node.modifiers?.some((mod) => mod.kind === ts.SyntaxKind.ExportKeyword)) {
      exportedTypes.add(node.name.text);
    }

    ts.forEachChild(node, visit);
  }

  visit(sourceFile);
  return exportedTypes;
}

async function run() {
  console.log("extracting components from api.d.ts...");

  const apiDefinitionPath = path.join(root, "src", ".generated", "api.d.ts");
  if (!existsSync(apiDefinitionPath)) {
    throw new Error(`API definition file not found: ${apiDefinitionPath}`);
  }

  const apiDefinition = await readFile(apiDefinitionPath, "utf-8");

  const schemasTypes = await getSchemasPackageTypes();
  console.log(`Found ${schemasTypes.size} types in @ucdjs/schemas:`, Array.from(schemasTypes).join(", "));

  const sourceFile = ts.createSourceFile(
    apiDefinitionPath,
    apiDefinition,
    ts.ScriptTarget.Latest,
    true,
  );

  let content = dedent`
          /**
           * This file is auto-generated by the \`generate:components\` script.
           * Do not edit this file directly.
           * Run \`pnpm generate:components\` to regenerate it.
           */

          import type { components } from "./.generated/api";
  `;

  let index = 0;

  function visit(node: ts.Node) {
    if (ts.isInterfaceDeclaration(node) && node.name.text === "components") {
      node.members.forEach((member) => {
        if (ts.isPropertySignature(member)
          && member.name
          && ts.isIdentifier(member.name)
          && member.name.text === "schemas") {
          if (member.type && ts.isTypeLiteralNode(member.type)) {
            member.type.members.forEach((schemaMember) => {
              if (!ts.isPropertySignature(schemaMember) || !ts.isIdentifier(schemaMember.name)) {
                return;
              }

              // Skip schemas that are already exported from @ucdjs/schemas
              if (schemasTypes.has(schemaMember.name.text)) {
                console.log(`Skipping ${schemaMember.name.text} (already exported from @ucdjs/schemas)`);
                return;
              }

              content += `${index === 0 ? "\n\n" : ""}export type ${schemaMember.name.text} = components["schemas"]["${schemaMember.name.text}"];\n`;
              index++;
            });
          }
        }
      });
    }

    ts.forEachChild(node, visit);
  }

  visit(sourceFile);

  await writeFile(path.join(root, "src", "components.ts"), content);
}

run().catch((err) => {
  console.error(err);
  process.exit(1);
});
