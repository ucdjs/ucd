name: Refresh UCD Store Manifest

on:
  schedule:
    - cron: "0 2 * * 1"
    - cron: "0 2 * * 4"

  workflow_dispatch:
    inputs:
      base_url:
        description: 'URL to trigger manifest refresh'
        required: false
        type: choice
        options: &urls
          - 'https://api.ucdjs.dev'
          - 'https://preview.api.ucdjs.dev'

permissions: {}

jobs:
  refresh:
    name: Refresh Manifest (${{ matrix.base_url }})
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        base_url: *urls
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          persist-credentials: false

      - name: setup pnpm
        uses: pnpm/action-setup@41ff72655975bd51cab0327fa583b6e92b6d3061 # v4.2.0

      - name: setup node
        uses: actions/setup-node@2028fbc5c25fe9cf00d9f06a71cc4710d4507903 # v6.0.0
        with:
          node-version: lts/*
          cache: pnpm

      - name: install dependencies
        run: pnpm install --frozen-lockfile

      - name: generate manifest
        if: github.event_name == 'schedule' || matrix.base_url == inputs.base_url
        uses: actions/github-script@v7
        with:
          script: |
            import { parse } from 'apache-autoindex-parse';
            import { traverse } from 'apache-autoindex-parse/traverse';
            import * as fs from 'node:fs';
            import * as path from 'node:path';

            const USER_AGENT = 'ucdjs (+https://github.com/ucdjs/ucd)';

            /**
             * Matches Unicode version directory names.
             * Supports formats like:
             * - "16.0.0", "15.1.0", "4.1.0"
             * - "4.1-Update", "4.1-Update1", "3.2-Update"
             */
            const VERSION_PATTERN = /^(\d+)\.(\d+)(?:\.(\d+))?(?:-Update\d*)?$/;

            function isVersionDirectory(name) {
              return VERSION_PATTERN.test(name);
            }

            async function getExpectedFilesForVersion(version) {
              const baseUrl = `https://unicode.org/Public/${version}`;

              try {
                const files = [];

                await traverse(baseUrl, {
                  extraHeaders: {
                    'User-Agent': USER_AGENT,
                  },
                  onFile: (file) => {
                    const relativePath = file.path.replace(`/${version}/`, '').replace(/^\//, '');
                    if (relativePath) {
                      files.push(relativePath);
                    }
                  },
                });

                return files;
              } catch (error) {
                console.error(`Failed to fetch files for version ${version}:`, error);
                return [];
              }
            }

            const startTime = Date.now();

            // Fetch version list from unicode.org
            console.log('Fetching version list from unicode.org...');
            const response = await fetch('https://unicode.org/Public?F=2', {
              headers: { 'User-Agent': USER_AGENT },
            });

            if (!response.ok) {
              throw new Error(`Failed to fetch unicode.org directory: ${response.status}`);
            }

            const html = await response.text();

            const entries = parse(html, 'F2');

            // Filter to only version directories
            const versionDirs = entries.filter((entry) => isVersionDirectory(entry.name.replace(/\/$/, '')));
            console.log(`Found ${versionDirs.length} versions to process`);

            const store = {};
            let totalFiles = 0;

            // Process versions in batches to avoid overwhelming unicode.org
            const BATCH_SIZE = 5;
            for (let i = 0; i < versionDirs.length; i += BATCH_SIZE) {
              const batch = versionDirs.slice(i, i + BATCH_SIZE);

              await Promise.all(
                batch.map(async (file) => {
                  const versionName = file.name.replace(/\/$/, '');
                  console.log(`Processing version ${versionName}`);
                  const expectedFiles = await getExpectedFilesForVersion(versionName);
                  store[versionName] = { expectedFiles };
                  totalFiles += expectedFiles.length;
                })
              );

              // Small delay between batches to be polite
              if (i + BATCH_SIZE < versionDirs.length) {
                await new Promise((resolve) => setTimeout(resolve, 500));
              }
            }

            const duration = Date.now() - startTime;
            console.log(`Generated manifest with ${Object.keys(store).length} versions in ${duration}ms`);
            console.log(`Total files tracked: ${totalFiles}`);

            // Write each version to a separate directory
            const outputDir = 'manifest-output';
            fs.mkdirSync(outputDir, { recursive: true });

            // Write individual version directories with meta file
            for (const [version, data] of Object.entries(store)) {
              const versionDir = path.join(outputDir, `ucdjs-manifest-v${version}`);
              fs.mkdirSync(versionDir, { recursive: true });

              // Write the manifest data
              fs.writeFileSync(
                path.join(versionDir, 'manifest.json'),
                JSON.stringify(data, null, 2)
              );

              // Write meta file for version validation
              fs.writeFileSync(
                path.join(versionDir, '.ucdjs-meta.json'),
                JSON.stringify({
                  version,
                  generatedAt: new Date().toISOString(),
                  fileCount: data.expectedFiles?.length || 0,
                }, null, 2)
              );
            }

            console.log(`Manifest files written to ${outputDir}/`);

      - name: Create and upload version tar files
        if: github.event_name == 'schedule' || matrix.base_url == inputs.base_url
        run: |
          cd manifest-output

          # Upload each version directory as a tar file
          failed=0
          for version_dir in ucdjs-manifest-v*/; do
            if [ ! -d "$version_dir" ]; then
              continue
            fi

            dir_name=$(basename "$version_dir")
            tar_name="${dir_name}.tar"
            echo "Creating and uploading $tar_name..."

            # Create tar with the directory contents
            tar -cvf "$tar_name" -C "$version_dir" .

            response=$(curl -s -w "\n%{http_code}" -X POST \
              -H "X-UCDJS-Task-Key: ${{ secrets.TASK_API_KEY }}" \
              -H "Content-Type: application/x-tar" \
              --data-binary @"$tar_name" \
              "${{ matrix.base_url }}/_tasks/upload-manifest")

            status=$(echo "$response" | tail -1)
            if [ "$status" != "200" ]; then
              echo "Failed to upload $dir_name"
              body=$(echo "$response" | sed '$d')
              echo "Response: $body"
              failed=$((failed + 1))
            else
              echo "$dir_name uploaded successfully"
            fi

            # Small delay between uploads
            sleep 0.5
          done

          if [ $failed -gt 0 ]; then
            echo "$failed version(s) failed to upload"
            exit 1
          fi

          echo "All versions uploaded successfully"
